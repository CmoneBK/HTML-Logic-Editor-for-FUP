<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Live Logik-Editor - Ultimate Smart Routing</title>
    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; height: 100vh; margin: 0; background-color: #1e1e1e; color: #d4d4d4; }
        
        #left-panel { width: 35%; padding: 20px; background: #252526; border-right: 2px solid #333; display: flex; flex-direction: column; gap: 15px; box-sizing: border-box; }
        #graph-container { width: 65%; padding: 0; display: flex; flex-direction: column; background: #ffffff; overflow: hidden; position: relative; box-sizing: border-box; }
        
        .header-area { display: flex; justify-content: space-between; align-items: baseline; }
        .header-title-wrapper { display: flex; align-items: baseline; gap: 12px; }
        h2 { margin: 0; color: #fff; font-size: 18px; }
        h3 { margin: 0 0 10px 0; color: #fff; font-size: 15px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        
        #save-indicator { font-size: 11px; color: #3cb44b; opacity: 0.3; transition: opacity 0.5s ease; font-weight: bold; }
        .btn-reset { background: none; border: none; color: #569CD6; font-size: 11px; cursor: pointer; text-decoration: underline; padding: 0; }
        .btn-reset:hover { color: #9CDCFE; }
        
        .graph-top-bar { display: flex; justify-content: space-between; align-items: center; gap: 15px; width: 100%; z-index: 10; padding: 10px 20px; box-sizing: border-box; background: #f8f9fa; border-bottom: 1px solid #ddd; }
        .btn-export { background-color: #007acc; color: white; border: none; padding: 8px 14px; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .btn-export:hover { background-color: #0098ff; }
        
        .info-box { background-color: #e3f2fd; border-left: 4px solid #2196f3; padding: 8px 12px; font-size: 12px; line-height: 1.4; color: #0d47a1; border-radius: 4px; flex-grow: 1; margin: 0; }
        
        .legend-box { background-color: #1e1e1e; border: 1px solid #444; padding: 10px; font-size: 12px; line-height: 1.4; color: #ccc; border-radius: 4px; display: flex; flex-direction: column; gap: 8px; }
        .legend-grid { display: grid; grid-template-columns: auto 1fr auto 1fr; gap: 5px 15px; align-items: center; }
        .legend-code { font-family: 'Courier New', Courier, monospace; background: #2d2d30; padding: 2px 6px; border-radius: 3px; font-weight: bold; color: #569CD6; user-select: all; cursor: pointer; border: 1px solid #555; }
        .legend-code.assign { color: #C586C0; }
        .legend-code.rs { color: #CE9178; border-color: transparent; background: transparent; padding: 0;}
        .legend-rs-note { padding-top: 8px; border-top: 1px dashed #444; font-size: 11.5px; }
        
        .editor-wrapper { position: relative; flex-grow: 1; min-height: 200px; background-color: #1e1e1e; border: 1px solid #444; border-radius: 4px; overflow: hidden; }
        
        #code, #highlighting { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            margin: 0; padding: 15px; border: none; box-sizing: border-box; 
            font-family: 'Courier New', Courier, monospace; font-size: 13px; line-height: 1.5; 
            letter-spacing: normal; word-spacing: normal; tab-size: 4; 
            white-space: pre-wrap; word-break: break-all; overflow-wrap: break-word;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
        }
        
        #code { color: transparent; background: transparent; caret-color: #d4d4d4; z-index: 2; resize: none; outline: none; overflow: auto; }
        #highlighting { z-index: 1; pointer-events: none; overflow: hidden; }
        #highlighting-content { display: block; font-family: inherit; font-size: inherit; line-height: inherit; padding: 0; margin: 0; border: none; color: #d4d4d4; }
        
        .token.assign { color: #C586C0; font-weight: bold; }
        .token.operator { color: #569CD6; font-weight: bold; }
        .token.paren { color: #FFD700; font-weight: bold; }
        .token.rs { color: #CE9178; }
        .token.comment { color: #6A9955; font-style: italic; }

        #simulator-panel { background: #2d2d30; border: 1px solid #444; border-radius: 4px; padding: 15px; display: flex; flex-direction: column; height: 35%; overflow-y: auto; }
        .sim-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .sim-col { display: flex; flex-direction: column; gap: 8px; }
        
        .sim-hint { font-size: 11px; color: #aaaaaa; margin-bottom: 5px; line-height: 1.4; background: #1e1e1e; padding: 6px; border-radius: 3px; border-left: 3px solid #007acc; }

        .switch-row { display: flex; justify-content: space-between; align-items: center; font-family: monospace; font-size: 13px; background: #1e1e1e; padding: 4px 8px; border-radius: 3px; border: 1px solid #333; }
        .switch { position: relative; display: inline-block; width: 34px; height: 18px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .2s; border-radius: 18px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 2px; bottom: 2px; background-color: white; transition: .2s; border-radius: 50%; }
        input:checked + .slider { background-color: #e6194B; }
        input:checked + .slider:before { transform: translateX(16px); }

        .taster-btn { background-color: #555; color: white; border: none; padding: 3px 10px; border-radius: 10px; cursor: pointer; font-family: monospace; font-size: 11px; font-weight: bold; transition: background-color 0.1s, transform 0.1s; user-select: none; }
        .taster-btn:active, .taster-btn.pressed { background-color: #3cb44b; transform: scale(0.95); }

        .led-row { display: flex; justify-content: space-between; align-items: center; font-family: monospace; font-size: 13px; background: #1e1e1e; padding: 4px 8px; border-radius: 3px; border: 1px solid #333; }
        .led { width: 14px; height: 14px; border-radius: 50%; background-color: #444; box-shadow: inset 0 0 3px #000; transition: background-color 0.1s; }
        .led.on { background-color: #f58231; box-shadow: 0 0 8px #f58231; }

        #svg-wrapper { flex-grow: 1; width: 100%; position: relative; background-image: radial-gradient(#e0e0e0 1px, transparent 1px); background-size: 20px 20px; }
        svg { width: 100%; height: 100%; cursor: grab; }
        svg:active { cursor: grabbing; }
        
        .fbs-block { fill: #ffffff; stroke-width: 2.5px; }
        .fbs-text { font-family: 'Segoe UI', Tahoma, sans-serif; font-size: 13px; fill: #000000; font-weight: bold; }
        .fbs-pin-text { font-family: 'Segoe UI', Tahoma, sans-serif; font-size: 10px; fill: #555555; }
        
        .fbs-line-halo { fill: none; stroke: #ffffff; stroke-width: 7px; stroke-linejoin: round; stroke-linecap: round; }
        .fbs-line { fill: none; stroke-width: 2.5px; stroke-linejoin: round; stroke-linecap: round; }
        .fbs-io-box { fill: #f0f0f0; stroke-width: 2px; rx: 4px; ry: 4px; }
    </style>
</head>
<body>
    <div id="left-panel">
        <div class="header-area">
            <div class="header-title-wrapper">
                <h2>Logik-Editor</h2>
                <span id="save-indicator">Gespeichert</span>
            </div>
            <button class="btn-reset" onclick="resetToDefault()">Beispiel laden</button>
        </div>

        <div class="legend-box">
            <div class="legend-grid">
                <span class="legend-code assign" title="Klicken zum Markieren">:=</span> <span>Zuweisung</span>
                <span class="legend-code" title="Klicken zum Markieren">&amp;&amp;</span> <span>UND (AND)</span>
                <span class="legend-code" title="Klicken zum Markieren">||</span> <span>ODER (OR)</span>
                <span class="legend-code" title="Klicken zum Markieren">¬</span> <span>NICHT (NOT)</span>
            </div>
            <div class="legend-rs-note">
                <strong>Info:</strong> Variablen wie <span class="legend-code rs">S1</span>, <span class="legend-code rs">R1</span>, <span class="legend-code rs">Q1</span> werden als <strong>RS-Glied</strong> interpretiert.
            </div>
        </div>

        <div class="editor-wrapper">
            <pre id="highlighting" aria-hidden="true"><code id="highlighting-content"></code></pre>
            <textarea id="code" spellcheck="false"></textarea>
        </div>

        <div id="simulator-panel">
            <div class="sim-grid">
                <div class="sim-col" id="sim-inputs"><h3>Eingänge</h3></div>
                <div class="sim-col" id="sim-outputs"><h3>Ausgänge</h3></div>
            </div>
        </div>
    </div>
    
    <div id="graph-container">
        <div class="graph-top-bar">
            <div class="info-box">
                <strong>Smart Fit & Routing:</strong> Keine verlorenen Leitungen mehr! Garantierte Mindestabstände verhindern das Durchschneiden von Gattern. Zwischenmerker (z.B. S2_MAN) leiten Signale sauber weiter.
            </div>
            <button class="btn-export" onclick="exportSVG()">Als SVG speichern</button>
        </div>
        
        <div id="svg-wrapper">
            <svg id="custom-svg" xmlns="http://www.w3.org/2000/svg">
                <g id="svg-halos"></g>
                <g id="svg-lines"></g>
                <g id="svg-nodes"></g>
            </svg>
        </div>
    </div>

    <script>
        const textarea = document.getElementById('code');
        const highlightingContent = document.getElementById('highlighting-content');
        
        const svgHalos = document.getElementById('svg-halos');
        const svgLines = document.getElementById('svg-lines');
        const svgNodes = document.getElementById('svg-nodes');
        
        const customSvg = document.getElementById('custom-svg');
        const saveIndicator = document.getElementById('save-indicator');
        
        const simInputsContainer = document.getElementById('sim-inputs');
        const simOutputsContainer = document.getElementById('sim-outputs');
        
        let panZoomInstance = null;
        let spsState = {};
        let simulationFunction = null;
        let saveTimeout = null;

        const DEFAULT_CODE = `S1 := ST
R1 := RT || NH
TEIL_OK := S_OPT_UE_SCHALTER && S_IND
S2_MAN := ST && Q1 && S_V1_AUS && S_V2_EIN
S2 := (Q1 && S_V1_AUS && S_V2_EIN) || S2_MAN
R2 := DONE || RT || NH || (ERR && S_V2_AUS)
PZ_V1_AUS := Q1 && TEIL_OK && ¬NH && ¬S_V1_AUS
PZ_V1_EIN := (DONE || RT || (ERR && S_V2_AUS)) && ¬NH && ¬S_V1_EIN
PZ_V2_AUS := Q2 && ¬NH
PZ_V2_EIN := (DONE || RT || (ERR && S_V2_AUS)) && ¬NH && ¬S_V2_EIN`;

        const palette = ['#e6194B', '#3cb44b', '#4363d8', '#f58231', '#911eb4', '#00b3b3', '#f032e6', '#8cbd00', '#008080', '#9a6324', '#800000', '#000075', '#808000', '#f08080', '#20b2aa', '#cd5c5c', '#ba55d3', '#ff1493', '#4b0082', '#ff8c00'];

        class LogicGraph {
            constructor() {
                this.nodes = new Map(); 
                this.edges = [];
                this.gateCounter = 0;
                this.colorIndex = 0;
            }

            addNode(id, type, label = id) {
                if (!this.nodes.has(id)) {
                    let c = '#333';
                    if (type === 'INPUT' || type === 'GATE' || type === 'RS') {
                        c = palette[this.colorIndex % palette.length];
                        this.colorIndex++;
                    }
                    this.nodes.set(id, { id, type, label, inputs: [], x: 0, y: 0, level: 0, color: c });
                }
                return this.nodes.get(id);
            }

            addEdge(sourceId, targetId, targetPin = '', inverted = false, originalSourceId = null) {
                const sourceNode = this.nodes.get(sourceId);
                const edgeColor = sourceNode ? sourceNode.color : '#333';
                const edgeObj = { sourceId, targetId, targetPin, color: edgeColor, inverted, originalSourceId: originalSourceId || sourceId };
                this.edges.push(edgeObj);
                
                const targetNode = this.nodes.get(targetId);
                if (targetNode) {
                    if (!targetNode.inputs.includes(sourceId)) targetNode.inputs.push(sourceId);
                    if (targetNode.type === 'OUTPUT') targetNode.color = edgeColor;
                }
            }
        }

        function parseToGraph(text) {
            const graph = new LogicGraph();
            const lines = text.split('\n');
            let jsCompiledCode = "";
            const definedOutputs = new Set();
            const allUsedInputs = new Set();
            const rsBlocks = new Set();
            const exprCache = new Map();

            function createGate(type, inputObjs) {
                const gateId = (type === '&' ? 'AND_' : 'OR_') + graph.gateCounter++;
                graph.addNode(gateId, 'GATE', type === '&' ? '&' : '>=1');
                inputObjs.forEach(inp => graph.addEdge(inp.id, gateId, '', inp.inverted));
                return gateId;
            }

            function evaluateFlat(expr) {
                expr = String(expr).trim();
                let inverted = false;
                
                if (expr.startsWith('¬')) {
                    inverted = true;
                    expr = expr.substring(1).trim();
                }

                if (expr.startsWith('AND_') || expr.startsWith('OR_')) return { id: expr, inverted }; 
                
                let canonicalKey = expr.replace(/\s+/g, '');
                if (exprCache.has(canonicalKey)) return { id: exprCache.get(canonicalKey), inverted };

                let resultId;
                let orParts = expr.split('||').map(s => s.trim());
                if (orParts.length > 1) { 
                    canonicalKey = orParts.map(s => s.replace(/\s+/g, '')).sort().join('||');
                    if (exprCache.has(canonicalKey)) return { id: exprCache.get(canonicalKey), inverted };
                    resultId = createGate('||', orParts.map(p => evaluateFlat(p))); 
                    exprCache.set(canonicalKey, resultId);
                    return { id: resultId, inverted };
                } 
                
                let andParts = expr.split('&&').map(s => s.trim());
                if (andParts.length > 1) { 
                    canonicalKey = andParts.map(s => s.replace(/\s+/g, '')).sort().join('&&');
                    if (exprCache.has(canonicalKey)) return { id: exprCache.get(canonicalKey), inverted };
                    resultId = createGate('&', andParts.map(p => evaluateFlat(p))); 
                    exprCache.set(canonicalKey, resultId);
                    return { id: resultId, inverted };
                }

                let rawInput = expr;
                let cleanId = rawInput.replace(/[^a-zA-Z0-9_]/g, '_');
                graph.addNode(cleanId, 'INPUT', rawInput);
                allUsedInputs.add(cleanId);
                resultId = cleanId;
                
                exprCache.set(canonicalKey, resultId);
                return { id: resultId, inverted };
            }

            function parseExpression(expr) {
                let parsed = expr;
                let changed = true;
                while (changed) {
                    changed = false;
                    parsed = parsed.replace(/\(([^()]+)\)/g, (match, inner) => {
                        changed = true;
                        let obj = evaluateFlat(inner);
                        return obj.inverted ? '¬' + obj.id : obj.id; 
                    });
                }
                return evaluateFlat(parsed);
            }

            lines.forEach(line => {
                let cleanLine = line.split('//')[0].trim();
                if (!cleanLine || !cleanLine.includes(':=')) return;

                const parts = cleanLine.split(':=');
                const outputStr = parts[0].trim();
                const expressionStr = parts[1].trim();

                const rsMatch = outputStr.match(/^([SR])(\d+)$/);
                let targetId = outputStr;
                let targetPin = '';

                if (rsMatch) {
                    const pin = rsMatch[1]; const num = rsMatch[2];
                    targetId = `RS_${num}`; targetPin = pin;
                    rsBlocks.add(num);
                    graph.addNode(targetId, 'RS', `RS-Glied ${num}`);
                    definedOutputs.add(`Q${num}`);
                } else {
                    graph.addNode(targetId, 'OUTPUT', outputStr);
                    definedOutputs.add(targetId);
                }

                const sourceObj = parseExpression(expressionStr);
                graph.addEdge(sourceObj.id, targetId, targetPin, sourceObj.inverted);

                let jsExpr = cleanLine.replace(/¬/g, '!').replace(':=', '=');
                jsExpr = jsExpr.replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\b/g, 'state.$1');
                jsCompiledCode += "    " + jsExpr + ";\n";
            });

            rsBlocks.forEach(num => {
                const rsId = `RS_${num}`;
                const qId = `Q${num}`;
                graph.addNode(qId, 'OUTPUT', qId);
                graph.addEdge(rsId, qId, 'Q');
                jsCompiledCode += `    if (state.R${num}) { state.Q${num} = false; } else if (state.S${num}) { state.Q${num} = true; }\n`;
            });

            graph.nodes.forEach(node => {
                if (!definedOutputs.has(node.id) && node.type === 'INPUT') node.type = 'PURE_INPUT';
            });

            return { graph, jsCompiledCode, inputs: [...allUsedInputs].filter(i => !definedOutputs.has(i) && !i.startsWith('AND_') && !i.startsWith('OR_')), outputs: [...definedOutputs] };
        }

        function calculateLayout(graph) {
            graph.nodes.forEach(node => { if (node.type === 'PURE_INPUT') node.level = 0; });

            let changed = true;
            let maxLoops = 100;
            while (changed && maxLoops > 0) {
                changed = false;
                maxLoops--;
                graph.nodes.forEach(node => {
                    if (node.type === 'PURE_INPUT') return;
                    let maxInputLevel = -1;
                    node.inputs.forEach(inId => {
                        const inNode = graph.nodes.get(inId);
                        if (inNode && inNode.level > maxInputLevel) maxInputLevel = inNode.level;
                    });
                    if (maxInputLevel >= 0 && node.level <= maxInputLevel) {
                        node.level = maxInputLevel + 1;
                        changed = true;
                    }
                });
            }

            let maxLevel = 0;
            graph.nodes.forEach(n => { if(n.level > maxLevel) maxLevel = n.level; });
            
            // Outputs nur ganz nach rechts zwingen, wenn sie nirgendwo als Eingang dienen (Final Outputs).
            // S2_MAN ist ein Zwischenmerker (hasOut ist true), deshalb bleibt er in seiner natürlichen Spalte!
            const hasOut = new Set(graph.edges.map(e => e.sourceId));
            graph.nodes.forEach(n => { if(n.type === 'OUTPUT' && !hasOut.has(n.id)) n.level = maxLevel + 1; });

            const columns = {};
            graph.nodes.forEach(node => {
                if (!columns[node.level]) columns[node.level] = [];
                columns[node.level].push(node);
            });

            const COLUMN_WIDTH = 220;
            const MIN_GAP = 25; // Sichert einen echten, durchlässigen Kanal zwischen allen Gattern
            
            Object.keys(columns).forEach(level => {
                let totalHeight = 0;
                
                columns[level].forEach(node => {
                    // Breite dynamisch an Textlänge anpassen
                    node.width = (node.type === 'RS' ? 50 : (node.type === 'GATE' ? 40 : Math.max(70, node.label.length * 7.5 + 15)));
                    node.height = (node.type === 'RS' ? 60 : (node.type === 'GATE' ? Math.max(30, node.inputs.length * 15 + 15) : 26));
                    totalHeight += node.height + MIN_GAP;
                });
                totalHeight -= MIN_GAP;

                // Zentriert die Stapel in Y-Richtung
                let currentY = Math.max(30, (600 - totalHeight) / 2); 
                columns[level].forEach(node => {
                    node.x = 40 + parseInt(level) * COLUMN_WIDTH;
                    node.y = currentY;
                    currentY += node.height + MIN_GAP; 
                });
            });
        }

        // Der extrem robuste Kollisions-Scanner
        function findFreeY(startY, x1, x2, nodes, horizontalUsage) {
            let blocked = [];
            // Erfasst alle Gatter-Höhen, die durchkreuzt werden würden
            for (let [id, n] of nodes) {
                if ((n.x - 10) < x2 && (n.x + n.width + 10) > x1) {
                    blocked.push({ min: n.y - 10, max: n.y + n.height + 10 });
                }
            }
            // Erfasst bereits liegende horizontale Hauptlinien
            for (let h of horizontalUsage) {
                if (Math.max(x1, h.x1) < Math.min(x2, h.x2)) {
                    blocked.push({ min: h.y - 5, max: h.y + 5 });
                }
            }
            
            // Scannt in 5-Pixel-Schritten spiralförmig nach oben und unten nach dem ersten freien Spalt
            for (let offset = 0; offset < 800; offset += 5) {
                for (let sign of [1, -1]) {
                    if (offset === 0 && sign === -1) continue;
                    let testY = startY + offset * sign;
                    let isBlocked = false;
                    for (let b of blocked) {
                        if (testY >= b.min && testY <= b.max) {
                            isBlocked = true;
                            break;
                        }
                    }
                    if (!isBlocked) return testY; // Freie Lücke gefunden!
                }
            }
            return startY; 
        }

        function drawPath(d, color) {
            const halo = document.createElementNS("http://www.w3.org/2000/svg", "path");
            halo.setAttribute("d", d);
            halo.setAttribute("class", "fbs-line-halo");
            svgHalos.appendChild(halo);

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", d);
            path.setAttribute("class", "fbs-line");
            path.setAttribute("stroke", color);
            svgLines.appendChild(path);
        }

        function drawBubble(cx, cy, color) {
            const bubble = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            bubble.setAttribute("cx", cx);
            bubble.setAttribute("cy", cy);
            bubble.setAttribute("r", 3.5);
            bubble.setAttribute("fill", "#ffffff");
            bubble.setAttribute("stroke", color);
            bubble.setAttribute("stroke-width", "2");
            svgNodes.appendChild(bubble);
        }

        function drawDot(cx, cy, color) {
            const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            dot.setAttribute("cx", cx);
            dot.setAttribute("cy", cy);
            dot.setAttribute("r", 4);
            dot.setAttribute("fill", color);
            svgNodes.appendChild(dot);
        }

        function drawGraph(graph) {
            svgHalos.innerHTML = '';
            svgLines.innerHTML = '';
            svgNodes.innerHTML = '';
            
            const channelUsage = {};
            const horizontalUsage = [];
            const nets = {};

            graph.edges.forEach(edge => {
                const source = graph.nodes.get(edge.sourceId);
                const target = graph.nodes.get(edge.targetId);
                if(!source || !target) return;

                let startY = source.y + (source.height / 2);
                if (source.type === 'RS' && edge.targetPin === 'Q') startY = source.y + 15;

                const netKey = edge.sourceId + '_' + startY;
                if (!nets[netKey]) nets[netKey] = { source, startY, edges: [], color: edge.color };
                nets[netKey].edges.push(edge);
            });

            Object.values(nets).forEach(net => {
                let startX = net.source.x + net.source.width;
                
                net.edges.forEach(edge => {
                    const target = graph.nodes.get(edge.targetId);
                    let endY = target.y + (target.height / 2);

                    if (target.type === 'GATE') {
                        const inIndex = target.inputs.indexOf(edge.originalSourceId);
                        const usableHeight = target.height - 20; 
                        const spacing = usableHeight / Math.max(1, target.inputs.length);
                        endY = target.y + 20 + spacing * (inIndex + 0.5); 
                    } else if (target.type === 'RS') {
                        if (edge.targetPin === 'S') endY = target.y + 15;
                        if (edge.targetPin === 'R') endY = target.y + target.height - 15;
                    }
                    edge.calcEndY = endY;
                    edge.calcEndX = target.x;
                    
                    if (!channelUsage[target.level]) channelUsage[target.level] = 0;
                    edge.calcMidX = target.x - 12 - (channelUsage[target.level] * 5);
                    channelUsage[target.level]++;
                });

                let maxMidX = Math.max(...net.edges.map(e => e.calcMidX));
                
                // Intelligente Y-Höhe für Trunk-Kabel finden
                let trunkY = net.startY;
                if (maxMidX > startX + 10) {
                    trunkY = findFreeY(net.startY, startX + 10, maxMidX, graph.nodes, horizontalUsage);
                    horizontalUsage.push({y: trunkY, x1: startX + 10, x2: maxMidX});
                }

                if (net.edges.length > 0 && maxMidX > startX) {
                    let trunkD = `M ${startX} ${net.startY}`;
                    if (Math.abs(trunkY - net.startY) > 2) {
                        trunkD += ` L ${startX + 10} ${net.startY} L ${startX + 10} ${trunkY} L ${maxMidX} ${trunkY}`;
                    } else {
                        trunkD += ` L ${maxMidX} ${trunkY}`; 
                    }
                    drawPath(trunkD, net.color);
                }

                const dots = new Set();

                net.edges.forEach(edge => {
                    let actualEndX = edge.calcEndX;
                    
                    if (edge.inverted) {
                        actualEndX -= 7;
                        drawBubble(actualEndX + 3.5, edge.calcEndY, net.color);
                    }

                    let dropD = "";
                    if (maxMidX > startX) {
                        // Zieht perfekt gerade Linien ohne Micro-Knicke, wenn möglich
                        if (Math.abs(trunkY - edge.calcEndY) <= 2) {
                            dropD = `M ${edge.calcMidX} ${trunkY} L ${actualEndX} ${trunkY}`;
                        } else {
                            dropD = `M ${edge.calcMidX} ${trunkY} L ${edge.calcMidX} ${edge.calcEndY} L ${actualEndX} ${edge.calcEndY}`;
                        }

                        let isJunction = false;
                        if (edge.calcMidX < maxMidX) {
                            isJunction = true; 
                        } else {
                            const edgesHere = net.edges.filter(e => e.calcMidX === edge.calcMidX);
                            const uniqueYs = new Set(edgesHere.map(e => e.calcEndY));
                            if (uniqueYs.size > 1) isJunction = true;
                        }
                        if (isJunction) dots.add(`${edge.calcMidX},${trunkY}`);
                    } else {
                        dropD = `M ${startX} ${net.startY} L ${edge.calcMidX} ${net.startY} L ${edge.calcMidX} ${edge.calcEndY} L ${actualEndX} ${edge.calcEndY}`;
                    }

                    drawPath(dropD, net.color);
                });

                dots.forEach(d => {
                    const [dx, dy] = d.split(',').map(Number);
                    drawDot(dx, dy, net.color);
                });
            });

            graph.nodes.forEach(node => {
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.setAttribute("transform", `translate(${node.x}, ${node.y})`);

                if (node.type === 'GATE' || node.type === 'RS') {
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("width", node.width);
                    rect.setAttribute("height", node.height);
                    rect.setAttribute("class", "fbs-block");
                    rect.setAttribute("stroke", node.color);
                    g.appendChild(rect);

                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", node.width / 2);
                    text.setAttribute("y", 15);
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("class", "fbs-text");
                    text.textContent = node.label;
                    g.appendChild(text);

                    if (node.type === 'RS') {
                        const sText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        sText.setAttribute("x", 4); sText.setAttribute("y", 18); sText.setAttribute("class", "fbs-pin-text"); sText.textContent = "S";
                        const rText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        rText.setAttribute("x", 4); rText.setAttribute("y", node.height - 10); rText.setAttribute("class", "fbs-pin-text"); rText.textContent = "R";
                        const qText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        qText.setAttribute("x", node.width - 12); qText.setAttribute("y", 18); qText.setAttribute("class", "fbs-pin-text"); qText.textContent = "Q";
                        g.appendChild(sText); g.appendChild(rText); g.appendChild(qText);
                    }
                } else {
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("width", node.width);
                    rect.setAttribute("height", node.height);
                    rect.setAttribute("class", "fbs-io-box");
                    rect.setAttribute("stroke", node.color);
                    
                    if (node.type === 'OUTPUT') {
                        rect.setAttribute("stroke-width", "3");
                        rect.setAttribute("fill", "#ffffff");
                    }
                    g.appendChild(rect);

                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", node.width / 2);
                    text.setAttribute("y", node.height / 2 + 4);
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("class", "fbs-text");
                    text.setAttribute("font-size", "11px");
                    
                    text.textContent = node.label;
                    
                    // Native SVG Stauchung, falls Text zu lang ist (Erzwingt Passform in Box)
                    const maxTextWidth = node.width - 10;
                    if (node.label.length * 6.5 > maxTextWidth) {
                        text.setAttribute("textLength", maxTextWidth);
                        text.setAttribute("lengthAdjust", "spacingAndGlyphs");
                    }
                    
                    const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
                    title.textContent = node.label;
                    text.appendChild(title);
                    
                    g.appendChild(text);
                }
                svgNodes.appendChild(g);
            });
            
            if (panZoomInstance) { panZoomInstance.destroy(); }
            panZoomInstance = svgPanZoom(customSvg, { zoomEnabled: true, controlIconsEnabled: true, fit: true, center: true });
        }

        function loadFromStorage() {
            const saved = localStorage.getItem('logikEditorCode');
            textarea.value = (saved !== null && saved.trim() !== "") ? saved : DEFAULT_CODE;
        }

        function saveToStorage() {
            localStorage.setItem('logikEditorCode', textarea.value);
            saveIndicator.style.opacity = '1';
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => { saveIndicator.style.opacity = '0.3'; }, 1000);
        }

        window.resetToDefault = function() {
            if (confirm("Möchtest du deinen aktuellen Code wirklich löschen und das Standard-Beispiel laden?")) {
                textarea.value = DEFAULT_CODE;
                updateHighlighting(); updateEditor(); saveToStorage();
            }
        };

        function updateHighlighting() {
            let text = textarea.value;
            if(text[text.length-1] === "\n") text += " ";
            text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            text = text.replace(/(\/\/.*)/g, '<span class="token comment">$1</span>');
            text = text.replace(/(:=)/g, '<span class="token assign">$1</span>');
            text = text.replace(/(&amp;&amp;|\|\||¬)/g, '<span class="token operator">$1</span>');
            text = text.replace(/(\(|\))/g, '<span class="token paren">$1</span>');
            text = text.replace(/\b([SRQ]\d+)\b/g, '<span class="token rs">$1</span>');
            highlightingContent.innerHTML = text;
        }

        textarea.addEventListener('scroll', () => { highlighting.scrollTop = textarea.scrollTop; highlighting.scrollLeft = textarea.scrollLeft; });

        function buildSimulatorUI(inputs, outputs) {
            const oldState = { ...spsState };
            spsState = {}; 
            simInputsContainer.innerHTML = `<h3>Eingänge</h3><div class="sim-hint"><b>Taster</b> geben Impulse.<br><b>NH</b>, <b>NA</b> oder <b>_SCHALTER</b> rasten ein.</div>`;

            inputs.forEach(name => {
                spsState[name] = oldState[name] || false; 
                const isSchalter = name === 'NH' || name === 'NA' || name.includes('_SCHALTER');
                if (isSchalter) {
                    simInputsContainer.innerHTML += `<div class="switch-row"><span>${name}</span><label class="switch"><input type="checkbox" id="sim_in_${name}" ${spsState[name] ? 'checked' : ''} onchange="toggleInput('${name}')"><span class="slider"></span></label></div>`;
                } else {
                    simInputsContainer.innerHTML += `<div class="switch-row"><span>${name}</span><button class="taster-btn" id="sim_taster_${name}" onmousedown="setTaster('${name}', true)" onmouseup="setTaster('${name}', false)" onmouseleave="setTaster('${name}', false)" ontouchstart="setTaster('${name}', true, event)" ontouchend="setTaster('${name}', false, event)">TASTER</button></div>`;
                }
            });

            simOutputsContainer.innerHTML = '<h3>Ausgänge</h3>';
            outputs.forEach(name => {
                if(!name.match(/^[SR]\d+$/)) {
                    spsState[name] = oldState[name] || false;
                    simOutputsContainer.innerHTML += `<div class="led-row"><span>${name}</span><div class="led" id="sim_out_${name}"></div></div>`;
                }
            });
            runSimulationTick();
        }

        window.toggleInput = function(varName) { spsState[varName] = document.getElementById(`sim_in_${varName}`).checked; runSimulationTick(); };
        window.setTaster = function(varName, isPressed, event) {
            if (event) event.preventDefault(); 
            spsState[varName] = isPressed;
            const btn = document.getElementById(`sim_taster_${varName}`);
            if (btn) { if (isPressed) btn.classList.add('pressed'); else btn.classList.remove('pressed'); }
            runSimulationTick();
        };

        function runSimulationTick() {
            if (!simulationFunction) return;
            simulationFunction(spsState);
            for (const [key, value] of Object.entries(spsState)) {
                const led = document.getElementById(`sim_out_${key}`);
                if (led) { if (value) led.classList.add('on'); else led.classList.remove('on'); }
            }
        }

        function updateEditor() {
            const code = textarea.value;
            try {
                const parsed = parseToGraph(code);
                
                try { simulationFunction = new Function('state', parsed.jsCompiledCode); } 
                catch(e) { console.error(e); simulationFunction = null; }
                buildSimulatorUI(parsed.inputs, parsed.outputs);
                
                calculateLayout(parsed.graph);
                drawGraph(parsed.graph);
                
            } catch (e) {
                console.warn("Warte auf korrekte Syntax...", e);
            }
        }

        function exportSVG() {
            const clone = customSvg.cloneNode(true);
            const viewport = clone.querySelector('.svg-pan-zoom_viewport');
            if (viewport) viewport.removeAttribute('transform');
            
            const serializer = new XMLSerializer();
            let source = serializer.serializeToString(clone);
            if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
            source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
            const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
            const downloadLink = document.createElement("a"); downloadLink.href = url; downloadLink.download = "logikplan-fbs.svg";
            document.body.appendChild(downloadLink); downloadLink.click(); document.body.removeChild(downloadLink);
        }

        textarea.addEventListener('input', () => { updateHighlighting(); updateEditor(); saveToStorage(); });
        loadFromStorage(); updateHighlighting(); updateEditor();
    </script>
</body>
</html>
